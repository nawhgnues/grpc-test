# Exploring gRPC

_Getting to Know gRPC (Lightly)_

## Folder StructureğŸ—‚ï¸

```
grpc-test/
â”œâ”€â”€ proto/                        # Common .proto files for all services
â”‚   â””â”€â”€ service.proto
â”‚
â”œâ”€â”€ python_server/                # Python-based gRPC server
â”‚   â”œâ”€â”€ server.py                 # Main server logic
â”‚   â”œâ”€â”€ requirements.txt          # pip dependency file
â”‚   â””â”€â”€ generated/                # gRPC code generated by protoc
â”‚       â”œâ”€â”€ service_pb2.py
â”‚       â””â”€â”€ service_pb2_grpc.py
â”‚
â”œâ”€â”€ ts_client/                    # TypeScript gRPC client
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ client.ts             # Client main logic (proto-loader)
â”‚   â”œâ”€â”€ proto/
â”‚   â”‚   â””â”€â”€ service.proto
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â””â”€â”€ node_modules/
â”‚
â””â”€â”€ README.md
```

---

## Recap

### ğŸ› ï¸ Flow

1. **Write the proto file**

- `.proto` : A file that defines service interfaces and data structures.

2. **Implement the server in Python**

- Using the proto file, service_pb2.py (defines message classes) and service_pb2_grpc.py (defines service classes and gRPC method stubs) are automatically generated.

```
- Message Classes: Define the data structures used in gRPC communication (request/response)
- Service Classes: Define the methods the server needs to implement (serve as interfaces)
- Stubs: Proxies that allow clients to make RPC calls
```

3. **Implement the client in TypeScript (proto-loader style)**

- `Proto-loader` : Loads proto files directly at runtime to use gRPC services. It's fast to develop with, but doesnâ€™t offer type autocompletion or compile-time type checking. (You can use static code generation tools like @grpc/grpc-js, ts-proto, or protobuf-ts instead.)

- Load information from the .proto file and use grpc.credentials.createInsecure() to create the stub.

- Use the stub on the client side to call the sayHello function implemented on the server.

---

### ImpressionsğŸ˜

- This feels like a much faster and more efficient way to communicate than using JSON-based communication.

- In a microservice architecture, gRPC servers can communicate internally and aggregate data before sending it to the frontendâ€”like a BFF (Backend For Frontend) server.

- Since itâ€™s a technology optimized for server-to-server communication, there seem to be limitations when connecting directly with the frontend (browser).
