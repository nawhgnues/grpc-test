# Exploring gRPC

_Getting to Know gRPC (Lightly)_

## Folder Structure🗂️

```
grpc-test/
├── proto/                        # Common .proto files for all services
│   └── service.proto
│
├── python_server/                # Python-based gRPC server
│   ├── server.py                 # Main server logic
│   ├── requirements.txt          # pip dependency file
│   └── generated/                # gRPC code generated by protoc
│       ├── service_pb2.py
│       └── service_pb2_grpc.py
│
├── ts_client/                    # TypeScript gRPC client
│   ├── src/
│   │   └── client.ts             # Client main logic (proto-loader)
│   ├── proto/
│   │   └── service.proto
│   ├── package.json
│   ├── tsconfig.json
│   └── node_modules/
│
└── README.md
```

---

## Recap

### 🛠️ Flow

1. **Write the proto file**

- `.proto` : A file that defines service interfaces and data structures.

2. **Implement the server in Python**

- Using the proto file, service_pb2.py (defines message classes) and service_pb2_grpc.py (defines service classes and gRPC method stubs) are automatically generated.

```
- Message Classes: Define the data structures used in gRPC communication (request/response)
- Service Classes: Define the methods the server needs to implement (serve as interfaces)
- Stubs: Proxies that allow clients to make RPC calls
```

3. **Implement the client in TypeScript (proto-loader style)**

- `Proto-loader` : Loads proto files directly at runtime to use gRPC services. It's fast to develop with, but doesn’t offer type autocompletion or compile-time type checking. (You can use static code generation tools like @grpc/grpc-js, ts-proto, or protobuf-ts instead.)

- Load information from the .proto file and use grpc.credentials.createInsecure() to create the stub.

- Use the stub on the client side to call the sayHello function implemented on the server.

---

### Impressions😎

- This feels like a much faster and more efficient way to communicate than using JSON-based communication.

- In a microservice architecture, gRPC servers can communicate internally and aggregate data before sending it to the frontend—like a BFF (Backend For Frontend) server.

- Since it’s a technology optimized for server-to-server communication, there seem to be limitations when connecting directly with the frontend (browser).
